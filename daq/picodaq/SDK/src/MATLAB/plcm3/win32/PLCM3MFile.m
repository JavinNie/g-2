function [methodinfo,structs,enuminfo,ThunkLibName]=PLCM3MFile
%PLCM3MFILE Create structures to define interfaces found in 'PLCM3Api'.

%This function was generated by loadlibrary.m parser version 1.1.6.37 on Wed Jun 25 11:46:27 2014
%perl options:'PLCM3Api.i -outfile=PLCM3MFile.m'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);
ThunkLibName=[];
% PICO_STATUS PLCM3Enumerate ( char * details , unsigned long * length , PLCM3_COMMUNICATION_TYPE type ); 
fcns.name{fcnNum}='PLCM3Enumerate'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'cstring', 'ulongPtr', 'enPLCM3CommunicationType'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3OpenUnit ( short * handle , char * serial ); 
fcns.name{fcnNum}='PLCM3OpenUnit'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'cstring'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3OpenUnitViaIp ( short * handle , char * serial , char * ipAddress ); 
fcns.name{fcnNum}='PLCM3OpenUnitViaIp'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'cstring', 'cstring'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3CloseUnit ( short handle ); 
fcns.name{fcnNum}='PLCM3CloseUnit'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3IpDetails ( short handle , short * enabled , char * ipaddress , unsigned short * length , unsigned short * listeningPort , PLCM3_IP_DETAILS_TYPE type ); 
fcns.name{fcnNum}='PLCM3IpDetails'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr', 'cstring', 'uint16Ptr', 'uint16Ptr', 'enPLCM3IpDetailsType'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3GetUnitInfo ( short handle , char * string , short stringLength , short * requiredSize , PICO_INFO info ); 
fcns.name{fcnNum}='PLCM3GetUnitInfo'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3SetChannel ( short handle , PLCM3_CHANNELS channel , PLCM3_DATA_TYPES type ); 
fcns.name{fcnNum}='PLCM3SetChannel'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPLCM3Channels', 'enPLCM3DataType'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3SetMains ( short handle , unsigned short sixtyHertz ); 
fcns.name{fcnNum}='PLCM3SetMains'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS PLCM3GetValue ( short handle , PLCM3_CHANNELS channel , long * value ); 
fcns.name{fcnNum}='PLCM3GetValue'; fcns.calltype{fcnNum}='cdecl'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPLCM3Channels', 'longPtr'};fcnNum=fcnNum+1;
enuminfo.enPLCM3CommunicationType=struct('PLCM3_CT_USB',1,'PLCM3_CT_ETHERNET',2,'PLCM3_CT_ALL',4294967295);
enuminfo.enPLCM3Channels=struct('PLCM3_CHANNEL_1',1,'PLCM3_CHANNEL_2',2,'PLCM3_CHANNEL_3',3,'PLCM3_MAX_CHANNELS',3);
enuminfo.enPLCM3IpDetailsType=struct('PLCM3_IDT_GET',0,'PLCM3_IDT_SET',1);
enuminfo.enPLCM3DataType=struct('PLCM3_OFF',0,'PLCM3_1_MILLIVOLT',1,'PLCM3_10_MILLIVOLTS',2,'PLCM3_100_MILLIVOLTS',3,'PLCM3_VOLTAGE',4,'PLCM3_MAX_DATA_TYPES',5);
methodinfo=fcns;